# -*- coding: utf-8 -*-
"""Untitled11.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lNUyVq6agATYnYPVcPbAZFjbJ8AQQ1tq
"""

import pandas as pd
pd.set_option('display.max_columns', None)

df = pd.read_csv("spotify_songs.csv")

df.info()

df.head()

feature_cols = [
    "danceability",
    "energy",
    "tempo",
    "valence",
    "acousticness",
    "loudness"
]


df = df[["track_id", "track_name", "track_artist"]+ feature_cols]
df.head()

def get_song_features(song_ids):
    """
    song_ids: list of track IDs
    Returns: numpy array shape (len(song_ids), num_features)
    """
    seed_df = df[df['track_id'].isin(song_ids)]
    return seed_df[feature_cols].values

from sklearn.preprocessing import StandardScaler
import numpy as np

scaler = StandardScaler()
X_all = scaler.fit_transform(df[feature_cols])

# Save for later use
import joblib
joblib.dump(scaler, "scaler.pkl")

def get_normalized_features(song_ids):
    seed_df = df[df['track_id'].isin(song_ids)]
    X_seed = seed_df[feature_cols].values
    return scaler.transform(X_seed)

def make_taste_vector(song_ids):
    """
    Takes list of song IDs, returns the averaged feature vector.
    """
    seed_features = get_normalized_features(song_ids)
    return np.mean(seed_features, axis=0, keepdims=True)

my_seeds = ["6f807x0ima9a1j3VPbc7VN", "75FpbthrwQmzHlBJLuGdC7"]  # Example IDs
taste_vector = make_taste_vector(my_seeds)
print(taste_vector)  # (1, num_features)

import torch

def make_taste_embedding(song_ids, model):
    taste_vector = make_taste_vector(song_ids)
    taste_tensor = torch.tensor(taste_vector, dtype=torch.float32)
    with torch.no_grad():
        taste_emb = model(taste_tensor).numpy()
    return taste_emb

import torch
import torch.nn as nn

class SongEmbedder(nn.Module):
    def __init__(self, input_dim=6, embedding_dim=32):
        super().__init__()
        self.fc = nn.Sequential(
            nn.Linear(input_dim, 64),
            nn.ReLU(),
            nn.Linear(64, embedding_dim)
        )

    def forward(self, x):
        return self.fc(x)

model = SongEmbedder()



all_song_embeddings = []
for i in range(len(df)):
    song_vector = get_normalized_features([df.iloc[i]['track_id']])
    emb = model(torch.tensor(song_vector, dtype=torch.float32)).detach().numpy()
    all_song_embeddings.append(emb[0])

from sklearn.metrics.pairwise import cosine_similarity

def recommend_songs(example_song_ids, model, all_song_embeddings, all_song_info, top_n=10):
    """
    example_song_ids: list of track IDs the user likes
    model: your PyTorch embedding model
    all_song_embeddings: precomputed embeddings for all songs in dataset (numpy array)
    all_song_info: dataframe with columns ['track_id', 'track_name', 'artists']
    top_n: number of recommendations to return
    """

    # 1. Compute the taste embedding from example songs
    taste_emb = make_taste_embedding(example_song_ids, model)  # shape (1, embedding_dim)

    # 2. Compute cosine similarity between taste and all songs
    similarities = cosine_similarity(taste_emb, all_song_embeddings)  # shape (1, num_songs)
    similarities = similarities.flatten()

    # 3. Exclude the example songs from recommendations
    example_set = set(example_song_ids)
    candidates = [(idx, score) for idx, score in enumerate(similarities)
                  if all_song_info.iloc[idx]['track_id'] not in example_set]

    # 4. Sort by similarity
    candidates.sort(key=lambda x: x[1], reverse=True)

    # 5. Take top N
    top_candidates = candidates[:top_n]

    # 6. Return human-readable list
    recommendations = []
    for idx, score in top_candidates:
        song = all_song_info.iloc[idx]
        recommendations.append({
            "track_id": song['track_id'],
            "track_name": song['track_name'],
            "track_artist": song['track_artist'],
            "similarity": float(score)
        })

    return recommendations

example_songs = ["6f807x0ima9a1j3VPbc7VN", "1e8PAfcKUYoKkxPhrHqw4x"]
recommendations = recommend_songs(example_songs, model, all_song_embeddings, df, top_n=5)

for i, rec in enumerate(recommendations, 1):
    print(f"{i}. {rec['track_name']} by {rec['track_artist']} (similarity: {rec['similarity']:.3f})")

